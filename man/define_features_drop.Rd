% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/growthcurve_features.R
\name{define_features_drop}
\alias{define_features_drop}
\title{Define curve-based features and summaries for training or validation data}
\usage{
define_features_drop(dataDT, ID, t_name, y, train_set = TRUE, hold_column,
  noNAs = FALSE, includeRLMIDind = FALSE,
  verbose = getOption("longDiSL.verbose"))
}
\arguments{
\item{dataDT}{Input data.table}

\item{ID}{A character string name of the column that contains the unique subject identifiers.}

\item{t_name}{A character string name of the column with integer-valued measurement time-points (in days, weeks, months, etc).}

\item{y}{A character string name of the column that represent the response variable in the model.}

\item{train_set}{Set to \code{TRUE} to define growth curve features and summaries for training data.
Set to \code{FALSE} to define the summaries for validation data. In the latter case the summaries are defined for observation (X_i,Y_i) by first dropping that observation
and then evaluating the summaries for the remaining observations. This is repeated in a loop for all person-time rows in the data.}

\item{hold_column}{A column with a logical flag for holdout rows / observations (\code{TRUE} indicates that the row is a holdout).
When \code{train_set} is \code{TRUE} the resulting output data will contain all non-HOLDOUT observations (training data points).
When \code{train_set} is \code{FALSE} the resulting output data will contain the HOLDOUT observations only (validation data points).
To evaluate either training or validation data summaries FOR ALL observations this argument must be missing
(in which case all observation from the input data are returned with their corresponding summaries).}

\item{noNAs}{...}

\item{includeRLMIDind}{...}

\item{verbose}{Set to \code{TRUE} to print messages on status and information to the console. Turn this on by default using \code{options(longDiSL.verbose=TRUE)}.}
}
\value{
...
}
\description{
Defines additional features and summaries of the growth curve person-time observations. Used for modeling and defining the training and validation sets
(e.g., random holdout and cross-validation).
By setting \code{train_set} to \code{TRUE} this function will define features using all data points as a
full training set (no holdouts, summaries use all person-time rows).
In contrast, when \code{train_set = TRUE} and \code{hold_column} is not missing, these features are defined only for non-holdout observations, excluding the holdout rows
(i.e., curve summaries will be defined based on training points only while dropping all holdout observations).
Finally, by setting \code{train_set} to \code{FALSE} one can create a validation dataset (e.g., for scoring with CV).
In this case the summaries and features will be defined for each row data point (X_i,Y_i)
by first dropping (X_i,Y_i) and then evaluating the summaries for (X_i,Y_i) based on the remaining observations.
This process is repeated in a loop for all person-time rows in the data.
}
\examples{
## ------------------------------------------------------------------------------------
## Features of the curve for training / validation sets (including random holdout and CV validation)
## ------------------------------------------------------------------------------------
test.holdout.features <- function() {
  options(longDiSL.verbose = TRUE)
  data(cpp)
  cpp <- cpp[!is.na(cpp[, "haz"]), ]
  covars <- c("apgar1", "apgar5", "parity", "gagebrth", "mage", "meducyrs", "sexn")
  head(cpp)
  nodes <- list(Lnodes = covars, Ynode = "haz", IDnode = "subjid", tnode = "agedays")

  ## add holdout indicator column
  cpp_holdout <- add_holdout_ind(data = cpp, ID = "subjid", hold_column = "hold", random = TRUE, seed = 12345)
  ## define CV folds (respecting that multiple observations per subject must fall within the same fold)
  cpp_folds <- add_CVfolds_ind(data = cpp, ID = "subjid", nfolds = 5, seed = 23)

  ## ------------------------------------------------------------------------------------
  ## Define features using all data points as a full training set (no holdouts, summaries use all obs)
  ## ------------------------------------------------------------------------------------
  cpp_all_train <- define_features(cpp_holdout, nodes = nodes, train_set = TRUE, holdout = FALSE)
  cpp_all_train2 <- define_features_drop(cpp_holdout, ID = "subjid", t_name = "agedays", y = "haz", train_set = TRUE)
  checkTrue(all.equal(cpp_all_train, cpp_all_train2))

  ## ------------------------------------------------------------------------------------
  ## Define grid of predictors
  ## ------------------------------------------------------------------------------------
  cpp_all_train <- define_features_drop(cpp_holdout, ID = "subjid", t_name = "agedays", y = "haz", train_set = TRUE)
  cpp_all_grid <- define_tgrid(cpp_all_train, ID = "subjid", t_name = "agedays", y = "haz", tmin = 1, tmax = 500, incr = 2, hold_column = "hold")

  ## ------------------------------------------------------------------------------------
  ## Define features for training rows excluding holdouts (summaries defined based on training points only while dropping the holdout observations)
  ## ------------------------------------------------------------------------------------
  ## TO DO: Might exclude holdout rows from final dataset, since their Y.lt / Y.rt are undefined anyways
  cpp_all_train_hold <- define_features(cpp_holdout, nodes = nodes, train_set = TRUE, holdout = TRUE)
  cpp_all_train_hold <- cpp_all_train_hold[hold != TRUE, ]
  ## By spec holdcolumn name we automatically exclude holdout rows
  cpp_all_train_hold2 <- define_features_drop(cpp_holdout, ID = "subjid", t_name = "agedays", y = "haz", train_set = TRUE, hold_column = "hold")
  checkTrue(all.equal(cpp_all_train, cpp_all_train2))

  ## ------------------------------------------------------------------------------------
  ## Define the validation data using ALL rows (e.g., for scoring with CV)
  ## These summaries / features are defined for each row data point (X_i,Y_i)
  ## by first dropping (X_i,Y_i) and then evaluating the summaries for (X_i,Y_i) based on the remaining observations.
  ## This process is repeated in a loop for all person-time rows in the data.
  ## ------------------------------------------------------------------------------------
  valid_data_all <- define_features(cpp_holdout, nodes, train_set = FALSE, holdout = FALSE)
  valid_data_all2 <- define_features_drop(cpp_holdout, ID = "subjid", t_name = "agedays", y = "haz", train_set = FALSE)
  checkTrue(all.equal(valid_data_all, valid_data_all2))

  valid_data_holdonly_test <- valid_data_all[hold == TRUE, ]
  valid_data_holdonly <- define_features_drop(cpp_holdout, ID = "subjid", t_name = "agedays", y = "haz", train_set = FALSE, hold_column = "hold")
  checkTrue(all.equal(valid_data_holdonly_test, valid_data_holdonly))
}


test.holdout.features.grid <- function() {
  valid_data_holdonly <- define_features_drop(cpp_holdout, ID = "subjid", t_name = "agedays", y = "haz", train_set = FALSE, hold_column = "hold")

  cpp_all_train2 <- define_features_drop(cpp_holdout, ID = "subjid", t_name = "agedays", y = "haz", train_set = TRUE)

define_features_drop
}



}

